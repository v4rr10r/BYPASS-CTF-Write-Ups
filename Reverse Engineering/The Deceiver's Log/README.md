#  The Deceiver's Log - BYPASS CTF 

## Challenge Information

| Field | Value |
|-------|-------|
| **CTF** | BYPASS CTF |
| **Category** | Rev |
| **Difficulty** | 	Medium |
| **Points** | 400 |

## Challenge Description

> "Words are wind, and maps are lies. Only the dead speak true, beneath the tides."
> 
> You've found the digital logbook of the infamous Captain "Ghost" Jack. It promises untold riches to those who can unlock it.
> But be warned: The Captain was a known liar. He built this log to mock those who try to steal his secrets.
> 
> The program seems... friendly enough. It might even give you a flag.
> But is it the *real* flag?
> 
> Trust nothing. Verify everything. The truth is fleeting, existing only for a moment before the lies take over.
> 
> Note: The flag format is BYPASS_CTF{...}

## Initial Analysis

We are provided with a 64-bit ELF binary named `deceivers_log`.

```bash
$ file deceivers_log
deceivers_log: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked...
```

Running the binary prompts us for a "secret code".

```bash
$ ./deceivers_log 
==========================================
       THE DECEIVER'S LOGBOOK            
==========================================
Captain verify me timbers!
Enter the secret code to unlock the log: test
Decrypting...
Too short, ye scurvy dog!
```

Using `strings` or a hex editor, we can find the required input string at offset `0x227d`.

```bash
$ strings deceivers_log | grep BYPASS
BYPASS_CTF
...
```

Providing `BYPASS_CTF` as the input unlocks the "chest".

```bash
$ echo "BYPASS_CTF" | ./deceivers_log
...
[+] Success! The chest opens!
[+] Here is your reward: BYPASS_CTF{C0ngr4ts_Captain_Y0u_B3at_Th3_Curse}
[+] (But is it real?)
```

The flag `BYPASS_CTF{C0ngr4ts_Captain_Y0u_B3at_Th3_Curse}` seems suspicious, especially given the challenge description warning us about lies.

## Static Analysis

Disassembling the binary with `objdump` or opening it in a decompiler reveals the internal logic.

### The Anti-Debugging Trick

At the very beginning of the execution (in a function called `init_chaos` or similar, invoked via `ptrace` check), the program checks if it is being debugged.

```assembly
401214:       call   ptrace   ; ptrace(PTRACE_TRACEME, 0, 0, 0)
401219:       test   rax,rax
40121c:       jns    40122c   ; Jump if Not Sign (rax >= 0) -> Success (No Debugger)
40121e:       mov    eax,DWORD PTR [g_chaos]
401224:       not    eax      ; Invert g_chaos
401226:       mov    DWORD PTR [g_chaos],eax
40122c:       nop
```

*   **No Debugger**: `ptrace` returns `0`. The jump is taken. `g_chaos` remains its initial value (`0x0badf00d`).
*   **Debugger Present**: `ptrace` returns `-1`. The jump is NOT taken. `g_chaos` is inverted (`~0x0badf00d`).

### The Deception Loop

In the `main` function, there is a loop that iterates through the flag characters.

```assembly
401984:       call   whisper_truth  ; Returns a character in AL
401989:       mov    BYTE PTR [rbp-0x51],al  ; Save result
40198c:       ...
401991:       call   shout_lies     ; Returns a character in AL (clobbers previous AL)
401996:       ...
40199c:       mov    BYTE PTR [rbp+rdx*1-0xa0],al ; Store AL in the print buffer
```

1.  `whisper_truth`: Calculates a character based on the current index and `g_chaos`.
2.  `shout_lies`: Calculates a character for the fake flag.
3.  The buffer used for printing the "reward" is filled with the result of `shout_lies`.

This confirms that the program **always prints the fake flag** (`shout_lies`), regardless of the debugging state. The real flag is generated by `whisper_truth` but is immediately overwritten in the register `AL` by the call to `shout_lies` before being stored in the print buffer.

## The Vulnerability

The "Real Flag" is generated by `whisper_truth`, but it depends on `g_chaos`.

*   `whisper_truth(i, chaos)` effectively returns `chaos ^ constant_i`.
*   **Normal Run**: `chaos` is `0x0badf00d`. `whisper_truth` returns `RealFlag`.
*   **Debug Run**: `chaos` is `~0x0badf00d`. `whisper_truth` returns `~RealFlag`.

Since we cannot easily see the output of `whisper_truth` during a normal run (it's not printed), we must use a debugger. However, attaching a debugger inverts `g_chaos`, causing `whisper_truth` to return the bitwise inverse of the real flag.

We can exploit this by:
1.  Running the program with GDB.
2.  Extracting the return values of `whisper_truth`.
3.  Inverting the bits (XOR with `0xFF`) to recover the Real Flag.

## Solution

### 1. GDB Script to Extract Values

We create a GDB script `solve.gdb` to break after `whisper_truth` returns and print the value in `AL`.

```gdb
# Break immediately after call to whisper_truth (address 0x401989)
break *0x401989
commands
  # Print the value in AL (lower 8 bits of RAX)
  print/c $al
  continue
end
# Run with the correct password
run < input.txt
quit
```

Create `input.txt` with the password:
```
BYPASS_CTF
```

### 2. Run GDB and Parse Output

Run GDB:
```bash
gdb -x solve.gdb ./deceivers_log > gdb_output.txt
```

The output will contain a series of values like:
```
$1 = -67 '\275'
$2 = -90 '\246'
...
```
These are the signed byte representations of `~RealFlag`.

### 3. Python Solver

We parse these values and invert them to get the flag.

```python
# Raw values extracted from GDB (unsigned 0-255)
# Example: -67 signed is 189 unsigned.
return_values = [
    189, 166, 175, 190, 172, 172, 160, 188, 171, 185, 132, 171, 141, 138, 202, 139,
    160, 177, 207, 160, 207, 145, 204, 160, 177, 207, 139, 160, 186, 137, 204, 145,
    160, 166, 207, 138, 141, 160, 186, 134, 204, 140, 130
]

flag = ""
for rv in return_values:
    # Invert the byte to reverse the effect of the anti-debugging check
    real_char = rv ^ 0xFF
    flag += chr(real_char)

print(f"Flag: {flag}")
```

### Output

Running the solver script yields the true flag:


## Flag:
 `BYPASS_CTF{Tru5t_N0_0n3_N0t_Ev3n_Y0ur_Ey3s}`

pwn by **W4RR1OR**
